(Pre-writing)

The semantics uses a few operators to make the Prolog source code more
like a labelled transition system:

The operator \verb+:+ is used to separate different part of a the name of
an entity a bit like \verb+.+ is used in Haskell and Java.

Different software components have input and output ports and (the
names of) these are wired together with the relation
\Tconnect{\cdot}{\cdot}.

Finally the ternary operator
\(\begin{array}{r@{}c@{}l}\Tstep{\mathit{Before}}{\mathit{Label}}{\mathit{After}}\end{array}\)
is used for the labeled transitions (reductions).

The top level labels are of the form \Tsay{A}{L}, \Thear{A}{L}, and
\Tdelta{T}.

The $L$ can be of the following forms

TODO: replace dot with colon.
TODO: format (instead of verbatim)

\begin{verbatim}
   I:R!new()
   I:R!term()              I:R?term()
   I:P:E!inv()             I:P:E?inv()
   I:P:E!rcv(V)            I:P:E?rcv(V)
                           I:P:E?rcv(no_data)
   I:P:E!rd(V)             I:P:E?rd(V)
   I:P:E!snd(V,Res)        I:P:E?snd(V,limit)
                           I:P:E?snd(V,ok)
   I:P:E!up(U)             I:P:E?up(U)
   I:P:E!wr(V)             I:P:E?wr(V)
   I:P:O!call(V,I:P:O,Res) I:P:O?call(V,C,limit)
   I:P:O!call(V,I:P:O,ok)  I:P:O?call(V,C,ok)
   I:P:O!res(V)            I:P:O?res(V)
                           I:P:O?res(no_data)
   I:P:O!ret(V)            I:P:O?ret(V)
   I:S!irvr(V)             I:S?irvr(V)
   I:S!irvw(V)             I:S?irvw(V)
   I:X!enter()             I:X?enter()
   I:X!exit()              I:X?exit()
\end{verbatim}

If we call the head of the part after the punctuation (\verb+!+ or
\verb+?+) the payload, we have the following payloads (sorted by the
part before the punctuation):

\begin{itemize}
\item \verb+I:R+:   \verb+new+, \verb+term+
\item \verb+I:P:E+: \verb+inv+, \verb+rcv+, \verb+rd+, \verb+snd+, \verb+up+, \verb+wr+
\item \verb+I:P:O+: \verb+call+, \verb+res+, \verb+ret+
\item \verb+I:S+:   \verb+irvr+, \verb+irvw+
\item \verb+I:X+:   \verb+enter+, \verb+exit+
\end{itemize}

\subsection{Combining reductions}

TODO: prettify and explain the function ``eval''. (The relational version is included further down.)

\[
\begin{array}{r@{}c@{}lcr@{}c@{}lr@{}c@{}l}
  \Prule{\Tstep{\Tpar{\Tvar{P1}}{\Tvar{Q1}}}{\Tsay{\Tvar{A}}{\Tvar{L}}}{\Tpar{\Tvar{P2}}{\Tvar{Q2}}}}{\Tstep{\Tvar{P1}}{\Tsay{\Tvar{A}}{\Tvar{L}}}{\Tvar{P2}},&\Tstep{\Tvar{Q1}}{\Thear{\Tvar{A}}{\Tvar{L}}}{\Tvar{Q2}}}.
\\\Prule{\Tstep{\Tpar{\Tvar{P1}}{\Tvar{Q1}}}{\Tsay{\Tvar{A}}{\Tvar{L}}}{\Tpar{\Tvar{P2}}{\Tvar{Q2}}}}{\Tstep{\Tvar{P1}}{\Thear{\Tvar{A}}{\Tvar{L}}}{\Tvar{P2}},&\Tstep{\Tvar{Q1}}{\Tsay{\Tvar{A}}{\Tvar{L}}}{\Tvar{Q2}}}.
\\\Prule{\Tstep{\Tpar{\Tvar{P1}}{\Tvar{Q1}}}{\Thear{\Tvar{A}}{\Tvar{L}}}{\Tpar{\Tvar{P2}}{\Tvar{Q2}}}}{\Tstep{\Tvar{P1}}{\Thear{\Tvar{A}}{\Tvar{L}}}{\Tvar{P2}},&\Tstep{\Tvar{Q1}}{\Thear{\Tvar{A}}{\Tvar{L}}}{\Tvar{Q2}}}.
\\\Prule{\Tstep{\Tpar{\Tvar{P1}}{\Tvar{Q1}}}{\Tdelta{\Tvar{T}}}{\Tpar{\Tvar{P2}}{\Tvar{Q2}}}}{\Tstep{\Tvar{P1}}{\Tdelta{\Tvar{T}}}{\Tvar{P2}},&\Tstep{\Tvar{Q1}}{\Tdelta{\Tvar{T}}}{\Tvar{Q2}}}.
\end{array}
\]

\subsection{Exclusive areas}
%\newcommand{\rte}[1]{\mathit{rte_{#1}}}
%\newcommand{\rte}[1]{\ensuremath{\mathit{rte\_#1}}}

Strict stack-based locking enforced: reduction gets stuck otherwise
(TODO: comment about flagging error on attempted "bad" \rte{Exit}?)
\[
\begin{array}{r@{}c@{}l}
\\\Pfact{\Tstep{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\TrteEnter{\Tvar{X}}{\Tvar{K}}}}{\Tsay{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{enter}}}{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tcons{\Tvar{X}}{\Tvar{Xs}}}{\Tap{\Tvar{K}}{\Tatom{ok}}}}}.
\\\Pfact{\Tstep{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tcons{\Tvar{X}}{\Tvar{Xs}}}{\TrteExit{\Tvar{X}}{\Tvar{K}}}}{\Tsay{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{exit}}}{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\Tap{\Tvar{K}}{\Tatom{ok}}}}}.
\\\Pfact{\Tstep{\Texcl{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{free}}}{\Thear{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{enter}}}{\Texcl{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{taken}}}}.
\\\Pfact{\Tstep{\Texcl{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{taken}}}{\Thear{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{exit}}}{\Texcl{\Tx{\Tvar{X}}{\Tvar{I}}}{\Tatom{free}}}}.
\end{array}
\]
\subsection{Inter-runnable variables}

\[
\begin{array}{r@{}c@{}l}
\\\Pfact{\Tstep{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\TrteIrvRead{\Tvar{S}}{\Tvar{K}}}}{\Tsay{\Ts{\Tvar{S}}{\Tvar{I}}}{\Tirvr{\Tvar{V}}}}{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\Tap{\Tvar{K}}{\Tvar{V}}}}}.
\\\Pfact{\Tstep{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\TrteIrvWrite{\Tvar{S}}{\Tvar{K}}}}{\Tsay{\Ts{\Tvar{S}}{\Tvar{I}}}{\Tirvw{\_V}}}{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\Tap{\Tvar{K}}{\Tatom{ok}}}}}.
\\\Pfact{\Tstep{\Tirv{\Ts{\Tvar{S}}{\Tvar{I}}}{\Tvar{V}}}{\Thear{\Ts{\Tvar{S}}{\Tvar{I}}}{\Tirvr{\Tvar{V}}}}{\Tirv{\Ts{\Tvar{S}}{\Tvar{I}}}{\Tvar{V}}}}.
\\\Pfact{\Tstep{\Tirv{\Ts{\Tvar{S}}{\Tvar{I}}}{\_}}{\Thear{\Ts{\Tvar{S}}{\Tvar{I}}}{\Tirvw{\Tvar{V}}}}{\Tirv{\Ts{\Tvar{S}}{\Tvar{I}}}{\Tvar{V}}}}.
\end{array}
\]


\subsection{Sending/receiving}

%TODO: Perhaps put "_" back in no_data: \newcommand{\nodata}{\ensuremath{\mathit{no\_data}}}

\[
\begin{array}{r@{}c@{}l}
\\\Pfact{\Tstep{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\TrteReceive{\Te{\Tvar{E}}{\Tvar{P}}}{\Tvar{K}}}}{\Tsay{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Trcv{\Tvar{V}}}}{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\Tap{\Tvar{K}}{\Tvar{V}}}}}.
\\\Pfact{\Tstep{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\TrteSend{\Te{\Tvar{E}}{\Tvar{P}}}{\Tvar{V}}{\Tvar{K}}}}{\Tsay{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tsnd{\Tvar{V}}{\Tvar{Res}}}}{\Trinst{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{C}}{\Tvar{Xs}}{\Tap{\Tvar{K}}{\Tvar{Res}}}}}.
\end{array}
\]

\[
\begin{array}{r@{}c@{}l}
\\\Pfact{\Tstep{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tcons{\Tvar{V}}{\Tvar{Vs}}}}{\Thear{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Trcv{\Tvar{V}}}}{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tvar{Vs}}}}.
\\\Pfact{\Tstep{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tatom{eps}}}{\Thear{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Trcv{\Tatom{nodata}}}}{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tatom{eps}}}}.
\end{array}
\]


\[
\begin{array}{r@{}c@{}lcl}
  \Prule{\Tstep{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tvar{Vs}}}{\Thear{\Tvar{A}}{\Tsnd{\Tvar{V}}{\Tatom{ok}}}}{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tseq{\Tvar{Vs}}{\Tvar{V}}}}}{\Tconnect{\Tvar{A}}{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}},\Tless{\Tlength{\Tvar{Vs}}}{\Tvar{N}}}.
\\\Prule{\Tstep{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tvar{Vs}}}{\Thear{\Tvar{A}}{\Tsnd{\_}{\Tatom{limit}}}}{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tvar{Vs}}}}{\Tconnect{\Tvar{A}}{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}},\Tequal{\Tlength{\Tvar{Vs}}}{\Tvar{N}}}.
\\\Prule{\Tstep{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tvar{Vs}}}{\Thear{\Tvar{A}}{\Tsnd{\Tvar{V}}{\Tatom{limit}}}}{\Tqelem{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}}{\Tvar{N}}{\Tseq{\Tvar{Vs}}{\Tvar{V}}}}}{\Tconnect{\Tvar{A}}{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}},\Tless{\Tlength{\Tvar{Vs}}}{\Tvar{N}}}.
\\\Prule{\Tstep{\Trunnable{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{K}}{\Tvar{T}}{\_}{\Tvar{N}}}{\Thear{\Tvar{A}}{\Tsnd{\_}{\Tatom{ok}}}}{\Trunnable{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{K}}{\Tvar{T}}{\Tatom{pending}}{\Tvar{N}}}}{\Tconnect{\Tvar{A}}{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}},\Tevents{\Tr{\Tvar{R}}{\Tvar{I}}}{\TdataReceived{\Te{\Tvar{E}}{\Tvar{P}}}}}.
\\\Prule{\Tstep{\Trunnable{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{K}}{\Tvar{T}}{\Tvar{Act}}{\Tvar{N}}}{\Thear{\Tvar{A}}{\Tsnd{\_}{\Tatom{limit}}}}{\Trunnable{\Tr{\Tvar{R}}{\Tvar{I}}}{\Tvar{K}}{\Tvar{T}}{\Tvar{Act}}{\Tvar{N}}}}{\Tconnect{\Tvar{A}}{\Tep{\Tvar{E}}{\Tvar{P}}{\Tvar{I}}},\Tevents{\Tr{\Tvar{R}}{\Tvar{I}}}{\TdataReceived{\Te{\Tvar{E}}{\Tvar{P}}}}}.
\end{array}
\]

\(\TdataReceived{\Te{\Tvar{E}}{\Tvar{P}}}\)
is a static property of this runnable from \Tatom{pending} it will
move on to spawn an \Tatom{rinst} which will execute some ``data
handler'' code.

%**TODO: continue

%TOD: compare order to semantics.eprover
\[
\begin{array}{r@{}c@{}l}
  \Tstep{runnable(R{:}I, K, T, \_, N)} {\Thear{A}{snd(\_V,ok)}}   {runnable(R{:}I, K, T, pending, N)}
\\ \multicolumn{3}{l}{\qquad \Pif    A\Rightarrow{}E{:}P{:}I, events(R{:}I, dataReceived(E{:}P))    .}
\\\Tstep{runnable(R{:}I, K, T, Act, N)}{\Thear{A}{snd(\_V,limit)}}{runnable(R{:}I, K, T, Act, N)}
\\ \multicolumn{3}{l}{\qquad \Pif    A\Rightarrow{}E{:}P{:}I, events(R{:}I, dataReceived(E{:}P))    .}
\end{array}
\]


\subsection{Reading/writing (unbuffered versions of rcv and snd)}


\[
\begin{array}{r@{}c@{}l}
  \Tstep{rinst(R{:}I, C, XS, \rte{Read}(E{:}P,K))}       {\Tsay{E{:}P{:}I}{rd(V)}} {rinst(R{:}I, C, XS, ap(K,V))} .
\\\Tstep{rinst(R{:}I, C, XS, \rte{Write}(E{:}P,V,K))}    {\Tsay{E{:}P{:}I}{wr(V)}} {rinst(R{:}I, C, XS, ap(K,ok))}.
\\\Tstep{delem(E{:}P{:}I, \_U, V)}                       {\Thear{E{:}P{:}I}{rd(V)}}{delem(E{:}P{:}I, false, V)}        .
\\\Tstep{delem(E{:}P{:}I, \_U, \_)}                      {\Thear{A}{wr(V)}}        {delem(E{:}P{:}I, true, V)}            \Pif    A\Rightarrow{}E{:}P{:}I .
\\\Tstep{runnable(R{:}I, K, T, \_, N)}                   {\Thear{A}{wr(\_V)}}      {runnable(R{:}I, K, T, pending, N)}    \Pif    A\Rightarrow{}E{:}P{:}I, events(R{:}I, dataReceived(E{:}P))    .
\\\Tstep{rinst(R{:}I, C, XS, \rte{IsUpdated}(E{:}P,K))}  {\Tsay{E{:}P{:}I}{up(U)}} {rinst(R{:}I, C, XS, ap(K,U))} .
\\\Tstep{rinst(R{:}I, C, XS, \rte{Invalidate}(E{:}P,K))} {\Tsay{E{:}P{:}I}{inv}}   {rinst(R{:}I, C, XS, ap(K,ok))}.
\\\Tstep{delem(E{:}P{:}I, U, V)}                         {\Thear{E{:}P{:}I}{up(U)}}{delem(E{:}P{:}I, U, V)} .
\\\Tstep{delem(E{:}P{:}I, \_U, \_)}                      {\Thear{A}{inv}}          {delem(E{:}P{:}I, true, invalid)}      \Pif    A\Rightarrow{}E{:}P{:}I .
\end{array}
\]


\subsection{Calling a server}

\newcommand{\Pcontline}[1]{\\\multicolumn{3}{l}{\qquad #1}}
\newcommand{\Pbackslashplus}{\mathbin{\backslash\!{+}}}
\[
\begin{array}{r@{}c@{}l}
  \Tstep{rinst(R{:}I, C, XS, \rte{Call}(O{:}P,V,K))}{\Tsay{O{:}P{:}I}{call(V,O{:}P{:}I,Res)}}{rinst(R{:}I, C, XS, ap(K,Res))}
  \Pcontline{\Pif serverCallPoint(R{:}I, async(O{:}P)) ; Res \neq ok   .}
\\\Tstep{rinst(R{:}I, C, XS, \rte{Call}(O{:}P,V,K))}{\Tsay{O{:}P{:}I}{call(V,O{:}P{:}I,ok)}}{rinst(R{:}I, C, XS, \rte{Result}(O{:}P,K))}
  \Pcontline{\Pif serverCallPoint(R{:}I, sync(O{:}P))  .}
\\\Tstep{runnable(R{:}I, K, T, serving(Cs,Vs), N)}{\Thear{A}{call(V,C,ok)}}{runnable(R{:}I, K, T, serving(CS++[C],Vs++[V]), N)}
  \Pcontline{\begin{array}{l}
               \Pif
             \\A\Rightarrow{}O{:}P{:}I, events(R{:}I, operationInvoked(O{:}P)),
             \\\Pbackslashplus member(C, Cs)
             \\.
             \end{array}}
\\\Tstep{runnable(R{:}I, K, T, serving(Cs,Vs), N)}{\Thear{A}{call(\_V,C,limit)}}{runnable(R{:}I, K, T, serving(Cs,Vs), N)}
  \Pcontline{\begin{array}{l}
               \Pif
             \\A\Rightarrow{}O{:}P{:}I, events(R{:}I, operationInvoked(O{:}P)),
             \\member(C, Cs)
             \\.
             \end{array}}
\end{array}
\]


\subsection{Obtaining a server result}

\[
\begin{array}{r@{}c@{}l}
  \Tstep{rinst(R{:}I, C, XS, \rte{Result}(O{:}P,K))}{\Tsay {O{:}P{:}I}{res(V)}}         {rinst(R{:}I, C, XS, ap(K,V))}  .
\\\Tstep{rinst(A, O{:}P{:}I, [], return(V))        }{\Tsay {O{:}P{:}I}{ret(V)}}         {rinst(A, nil, [], return(void))}.
\\\Tstep{opres(O{:}P{:}I, [V|Vs])                  }{\Thear{O{:}P{:}I}{res(V)}}        {opres(O{:}P{:}I, Vs)}               .
\\\Tstep{opres(O{:}P{:}I, [])                      }{\Thear{O{:}P{:}I}{res(\nodata)}}  {opres(O{:}P{:}I, [])}
  \Pcontline{\Pif    async\_result(O{:}P{:}I)   .}
\\\Tstep{opres(O{:}P{:}I, Vs)                      }{\Thear{O{:}P{:}I}{ret(V)}}        {opres(O{:}P{:}I, Vs++[V])} .
\end{array}
\]


\subsection{Spawning and terminating}

\[
\begin{array}{r@{}c@{}l}
  \Tstep{rinst(A, nil, [], return(\_V))}{\Tsay{A}{term}}{[]}    .
\\\Tstep{runnable(A, K, T, Act, N)}{\Thear{A}{term}}{runnable(A, K, T, Act, N-1)}.
\end{array}
\]

Note the "time left" state has to be zero for these rules to fire.

\[
\begin{array}{r@{}c@{}l}
  \Tstep{runnable(A, K, 0, pending, N)}{\Tsay{A}{new}}{\begin{array}{l}
                                                        [ runnable(A, K, T, idle, N+1)
                                                      \\, rinst(A, nil, [], ap(K,void)) ]
                                                     \end{array}}
  \Pcontline{\begin{array}{l}
               \Pif
             \\(N == 0 ; canBeInvokedConcurrently(A)),
             \\minimumStartInterval(A, T)
             \\.
             \end{array}}
\\\Tstep{runnable(A, K, 0, serving([C|Cs],[V|Vs]), N)}{\Tsay{A}{new}}{[ runnable(A, K, T, serving(Cs,Vs), N+1)
                                                                   , rinst(A, C, [], ap(K,V)) ]}
  \Pcontline{\begin{array}{l}
               \Pif
             \\(N == 0 ; canBeInvokedConcurrently(A)),
             \\minimumStartInterval(A, T)
             \\.
             \end{array}}
\end{array}
\]

\subsection{Passing time}


\[
\begin{array}{r@{}c@{}lcl}
  \Tstep{timer(A, 0)             }{\Tsay{A}{tick}} {timer(A, T)}                   & \Pif&    events(A, timing(T))    .
\\\Tstep{runnable(A, K, T, \_, N)}{\Thear{A}{tick}}{runnable(A, K, T, pending, N)} .
\end{array}
\]


The ``time left'' state \(V\) is always decreasing in \(\delta(T)\) steps, and never negative.

\[
\begin{array}{r@{}c@{}lcl}
  \Tstep{timer(A, V)              }{\delta(T)  }{timer(A, V-T)              } &\Pif&    V >= T.
\\\Tstep{runnable(A, K, V, Act, N)}{\delta(T)  }{runnable(A, K, V-T, Act, N)} &\Pif&    V >= T.
\\\Tstep{runnable(A, K, 0, Act, N)}{\delta(\_T)}{runnable(A, K, 0, Act, N)  }.
\\\Tstep{rinst(A, C, XS, Code)    }{\delta(\_T)}{rinst(A, C, XS, Code)      }.
\\\Tstep{excl(A, V)               }{\delta(\_T)}{excl(A, V)                 }.
\\\Tstep{irv(A, V)                }{\delta(\_T)}{irv(A, V)                  }.
\\\Tstep{qelem(A, N, Vs)          }{\delta(\_T)}{qelem(A, N, Vs)            }.
\\\Tstep{delem(A, U, V)           }{\delta(\_T)}{delem(A, U, V)             }.
\\\Tstep{opres(A, Vs)             }{\delta(\_T)}{opres(A, Vs)               }.
\end{array}
\]

\subsection{Ignoring broadcasts}

TODO: continue converting.

\begin{verbatim}
ignore(\_AL, rinst(\_B,\_C,\_Xs,\_K))   .
ignore(\_AL, timer(\_B,\_T))             .

ignore((A,\_L), runnable(B, \_K, \_T, \_Act, \_N))   \Pif A \== B.
ignore((A,\_L), excl(B,\_V))                         \Pif A \== B.
ignore((A,\_L), irv(B,\_V))                          \Pif A \== B.
ignore((A,\_L), qelem(B,\_N,\_Vs))                   \Pif A \== B, \+ A\Rightarrow{}B.
ignore((A,\_L), delem(B,\_U,\_V))                    \Pif A \== B, \+ A\Rightarrow{}B.
ignore((A,\_L), opres(B,\_Vs))                       \Pif A \== B, \+ A\Rightarrow{}B.
\end{verbatim}


\subsection{Helper predicate: flattening and evaluating reduction results}

\begin{verbatim}
flateval([],              Q, Q)  \Pif !  .
flateval([ M | P ],       Q, R)  \Pif !, flateval(P, Q, R1),  flateval(M, R1, R)  .
flateval(rinst(A,C,Xs,M), Q, [ rinst(A,C,Xs,N) | Q ])  \Pif !, eval(M, N)   .
flateval(M,               Q, [ M               | Q ]).
\end{verbatim}

Experiment with "treelike" process soup
\begin{verbatim}
treeeval([],              [])         \Pif !  .
treeeval([ M | P ],       [M2 | P2])  \Pif !, treeeval(M, M2), treeeval(P, P2).
treeeval(rinst(A,C,Xs,M), [ rinst(A,C,Xs,N) | \_Q ])  \Pif !, eval(M, N)   .
treeeval(M,               [ M               | \_Q ]).
\end{verbatim}

\subsection{Helper predicate: evaluating terms}

\begin{verbatim}
eval(V, V)              \Pif    var(V), !    .
eval(ap(T,V), ap(T,V))  \Pif    var(T), !    .
eval(ap(F,E), R)        \Pif    eval(F, fn(X,T)), !,    eval(E, V),    X = V,    eval(T, R)    .
eval(ap(T,\_V), R)       \Pif !, eval(T, R)   .
eval(fn(X,T), fn(X,T))  \Pif ! .
eval(if(E,A,\_B), R)     \Pif    E,    !, eval(A, R)    .
eval(if(E,\_A,B), R)     \Pif    \+ E, !, eval(B, R)    .
eval((A,B), (A1,B1))    \Pif !, eval(A, A1),     eval(B, B1)    .
eval([A|B], [A1|B1])    \Pif !, eval(A, A1),     eval(B, B1)    .
eval((A{:}B), (A1:B1))    \Pif !, eval(A, A1),     eval(B, B1)    .
eval(E, R)              \Pif    E =.. [H|As], funWithArgsToEvaluate(H), !, eval(As, Bs), R =.. [H|Bs].
eval(V, V)              \Pif    atom(V), !  .
eval(E, R)              \Pif    R is E      .

funWithArgsToEvaluate(H)\Pif name(H,N), (append("rte_",_,N) ; N = "return").
\end{verbatim}
