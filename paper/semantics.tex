(Pre-writing)

The semantics uses a few operators to make the Prolog source code more
like a labelled transition system:

The operator \verb+:+ is used to separate different part of a the name of
an entity a bit like \verb+.+ is used in Haskell and Java.

Different software components have input and output ports and (the
names of) these are wired together with the relation \verb+==>+

Finally the ternary operator ``Before \verb+---+ Label \verb+--->+
After'' is used for the labeled transitions (reductions).

The top level labels are of the form \verb+say(A,L)+,
\verb+hear(A,L)+, and \verb+delta(T)+.

The \verb+L+ can be of the following forms

TODO: replace dot with colon.
TODO: format (instead of verbatim)

\begin{verbatim}
   I.R!new()
   I.R!term()              I.R?term()
   I.P.E!inv()             I.P.E?inv()
   I.P.E!rcv(V)            I.P.E?rcv(V)
                           I.P.E?rcv(no_data)
   I.P.E!rd(V)             I.P.E?rd(V)
   I.P.E!snd(V,Res)        I.P.E?snd(V,limit)
                           I.P.E?snd(V,ok)
   I.P.E!up(U)             I.P.E?up(U)
   I.P.E!wr(V)             I.P.E?wr(V)
   I.P.O!call(V,I.P.O,Res) I.P.O?call(V,C,limit)
   I.P.O!call(V,I.P.O,ok)  I.P.O?call(V,C,ok)
   I.P.O!res(V)            I.P.O?res(V)
                           I.P.O?res(no_data)
   I.P.O!ret(V)            I.P.O?ret(V)
   I.S!irvr(V)             I.S?irvr(V)
   I.S!irvw(V)             I.S?irvw(V)
   I.X!enter()             I.X?enter()
   I.X!exit()              I.X?exit()
\end{verbatim}

If we call the head of the part after the punctuation (\verb+!+ or
\verb+?+) the payload, we have the following payloads (sorted by the
part before the punctuation):

\begin{itemize}
\item \verb+I.R+:   \verb+new+, \verb+term+
\item \verb+I.P.E+: \verb+inv+, \verb+rcv+, \verb+rd+, \verb+snd+, \verb+up+, \verb+wr+
\item \verb+I.P.O+: \verb+call+, \verb+res+, \verb+ret+
\item \verb+I.S+:   \verb+irvr+, \verb+irvw+
\item \verb+I.X+:   \verb+enter+, \verb+exit+
\end{itemize}

\subsection{Combining reductions}

TODO: prettify and explain the function ``eval''. (The relational version is included further down.)

% \newcommand{\Preduce}[3]{#1 \texttt{---} #2 \texttt{--->} #3}
\newcommand{\Preduce}[3]{\ensuremath{#1 &\xrightarrow{#2}& #3}}
\newcommand{\Pignore}[1]{\ensuremath{\mathit{ignore}#1}}
\newcommand{\Pif}{\ensuremath{\mathbin{:\!\!-}}}
\[
\begin{array}{r@{}c@{}lcr@{}c@{}lr@{}c@{}l}
  \Preduce{[]}{hear(\_A,\_L)}{[]}. & &
\\\Preduce{[ P | Ps ]}{say(A,L)} {concat(eval([P2 | Ps2]))}  &\Pif& \Preduce{P}{say(A,L)}{P2}  ,&  \Preduce{Ps}{hear(A,L)}{Ps2}.
\\\Preduce{[ P | Ps ]}{say(A,L)} {[ P2 | Ps2 ]}  &\Pif& \Preduce{P} {hear(A,L)}{P2}   ,&  \Preduce{Ps}{say(A,L)} {Ps2} .
\\\Preduce{[ P | Ps ]}{hear(A,L)}{[ P2 | Ps2 ]}  &\Pif& \Preduce{P} {hear(A,L)}{P2}   ,&  \Preduce{Ps}{hear(A,L)}{Ps2} .
\\\Preduce{[ P | Ps ]}{say(A,L)} {[ P  | Ps2 ]}  &\Pif& \Preduce{Ps}{say(A,L)} {Ps2}  ,&  \multicolumn{3}{c}{\Pignore{((A,L),P)}}    .
\\\Preduce{[ P | Ps ]}{hear(A,L)}{[ P  | Ps2 ]}  &\Pif& \Preduce{Ps}{hear(A,L)}{Ps2}  ,&  \multicolumn{3}{c}{\Pignore{((A,L),P)}}    .
\\\Preduce{[]}{\delta(\_T)}{[]}. & &
\\\Preduce{[ P | Ps ]}{\delta(T)}{[ P2 | Ps2 ]}  &\Pif& \Preduce{P}{\delta(T)}{P2}    ,&  \Preduce{Ps}{\delta(T)}{Ps2}  .
\end{array}
\]

Think of
\(\begin{array}{r@{}c@{}l}\Pignore{((A,L),P)} \Pif
  \Preduce{P}{hear(A,L)}{P}\end{array}\).
but implemented to avoid overlap.

TODO: can \Pignore{((A,L),P)} be written before the other reduction on the RHS?



\subsection{Exclusive areas}
%\newcommand{\rte}[1]{\mathit{rte_{#1}}}
\newcommand{\rte}[1]{\ensuremath{\mathit{rte\_#1}}}

Strict stack-based locking enforced: reduction gets stuck otherwise
(TODO: comment about flagging error on attempted "bad" \rte{Exit}?)
\[
\begin{array}{r@{}c@{}l}
  \Preduce{rinst(R{:}I, C, Xs,     \rte{Enter}(X,K))}{say(X{:}I,enter)} {rinst(R{:}I, C, [X|Xs], ap(K,ok))}  .
\\\Preduce{rinst(R{:}I, C, [X|Xs], \rte{Exit}(X,K))} {say(X{:}I,exit)}  {rinst(R{:}I, C, Xs,     ap(K,ok))}      .
\\\Preduce{excl(X{:}I, free)}                     {hear(X{:}I,enter)}{excl(X{:}I, taken)}                 .
\\\Preduce{excl(X{:}I, taken)}                    {hear(X{:}I,exit)} {excl(X{:}I, free)}                  .
\end{array}
\]
\subsection{Inter-runnable variables}

\[
\begin{array}{r@{}c@{}l}
  \Preduce{rinst(R{:}I, C, Xs, \rte{IrvRead}(S,K))} {say(S{:}I,irvr(V))}  {rinst(R{:}I, C, Xs, ap(K,V))}  .
\\\Preduce{rinst(R{:}I, C, Xs, \rte{IrvWrite}(S,K))}{say(S{:}I,irvw(\_V))}{rinst(R{:}I, C, Xs, ap(K,ok))} .
\\\Preduce{irv(S{:}I, V)}                           {hear(S{:}I,irvr(V))} {irv(S{:}I, V)}                 .
\\\Preduce{irv(S{:}I,\_)}                           {hear(S{:}I,irvw(V))} {irv(S{:}I, V)}                 .
\end{array}
\]


\subsection{Sending/receiving}

\[
\begin{array}{r@{}c@{}l}
  \Preduce{rinst(R{:}I, C, Xs, \rte{Receive}(E{:}P,K))}{say(E{:}P{:}I,rcv(V))}    {rinst(R{:}I, C, Xs, ap(K,V))} .
\\\Preduce{rinst(R{:}I, C, Xs, \rte{Send}(E{:}P,V,K))} {say(E{:}P{:}I,snd(V,Res))}{rinst(R{:}I, C, Xs, ap(K,Res))}.
\end{array}
\]

\newcommand{\nodata}{\ensuremath{\mathit{no\_data}}}
\[
\begin{array}{r@{}c@{}l}
  \Preduce{qelem(E{:}P{:}I, N, [V|Vs])}{hear(E{:}P{:}I,rcv(V))}      {qelem(E{:}P{:}I, N, Vs)}    .
\\\Preduce{qelem(E{:}P{:}I, N, [])}    {hear(E{:}P{:}I,rcv(\nodata))}{qelem(E{:}P{:}I, N, [])}    .
\end{array}
\]


\[
\begin{array}{r@{}c@{}lcl}
  \Preduce{qelem(E{:}P{:}I, N, Vs)}{hear(A,snd(V,ok))}{qelem(E{:}P{:}I, N, Vs++[V])}
    &\Pif &   A\Rightarrow{}E{:}P{:}I, length(Vs) < N.
\\\Preduce{qelem(E{:}P{:}I, N, Vs)}{hear(A,snd(\_V,limit))}{qelem(E{:}P{:}I, length(Vs), Vs)}
    &\Pif &   A\Rightarrow{}E{:}P{:}I    .
\\\Preduce{qelem(E{:}P{:}I, N, Vs)}{hear(A,snd(V,Res))}{qelem(E{:}P{:}I, N, Vs++[V])}
    &\Pif &   A\Rightarrow{}E{:}P{:}I, length(Vs) < N, Res \neq ok    .
\end{array}
\]

\(dataReceived(E{:}P)\) is a static property of this runnable
  from pending it will move on to spawn an rinst which will execute some ``data handler'' code.
\begin{verbatim}
runnable(R:I, K, T, _, N)                --- hear(A,snd(_V,ok)) --->   runnable(R:I, K, T, pending, N)
    :-    A==>E:P:I, events(R:I, dataReceived(E:P))    .
runnable(R:I, K, T, Act, N)              --- hear(A,snd(_V,limit)) --->runnable(R:I, K, T, Act, N)
    :-    A==>E:P:I, events(R:I, dataReceived(E:P))    .
\end{verbatim}

\subsection{Reading/writing (unbuffered versions of rcv and snd)}

\begin{verbatim}
rinst(R:I, C, XS, rte_Read(E:P,K))       --- say(E:P:I,rd(V)) --->     rinst(R:I, C, XS, ap(K,V)) .
rinst(R:I, C, XS, rte_Write(E:P,V,K))    --- say(E:P:I,wr(V)) --->     rinst(R:I, C, XS, ap(K,ok)).
delem(E:P:I, _U, V)                      --- hear(E:P:I,rd(V)) --->    delem(E:P:I, false, V)        .
delem(E:P:I, _U, _)                      --- hear(A,wr(V)) --->        delem(E:P:I, true, V)
    :-    A==>E:P:I .
runnable(R:I, K, T, _, N)                --- hear(A,wr(_V)) --->       runnable(R:I, K, T, pending, N)
    :-    A==>E:P:I, events(R:I, dataReceived(E:P))    .
rinst(R:I, C, XS, rte_IsUpdated(E:P,K))  --- say(E:P:I,up(U)) --->     rinst(R:I, C, XS, ap(K,U)) .
rinst(R:I, C, XS, rte_Invalidate(E:P,K)) --- say(E:P:I,inv) --->       rinst(R:I, C, XS, ap(K,ok)).
delem(E:P:I, U, V)                       --- hear(E:P:I,up(U)) --->    delem(E:P:I, U, V)            .
delem(E:P:I, _U, _)                      --- hear(A,inv) --->          delem(E:P:I, true, invalid)
    :-    A==>E:P:I .
\end{verbatim}

\subsection{Calling a server}

\begin{verbatim}
rinst(R:I, C, XS, rte_Call(O:P,V,K))     --- say(O:P:I,call(V,O:P:I,Res)) --->  rinst(R:I, C, XS, ap(K,Res))
    :- serverCallPoint(R:I, async(O:P)) ; Res \= ok   .
rinst(R:I, C, XS, rte_Call(O:P,V,K))     --- say(O:P:I,call(V,O:P:I,ok)) --->   rinst(R:I, C, XS, rte_Result(O:P,K))
    :- serverCallPoint(R:I, sync(O:P))  .
runnable(R:I, K, T, serving(Cs,Vs), N)   --- hear(A,call(V,C,ok)) --->          runnable(R:I, K, T, serving(CS++[C],Vs++[V]), N)
    :-
    A==>O:P:I, events(R:I, operationInvoked(O:P)),
    \+ member(C, Cs)
    .
runnable(R:I, K, T, serving(Cs,Vs), N)   --- hear(A,call(_V,C,limit)) --->      runnable(R:I, K, T, serving(Cs,Vs), N)
    :-
    A==>O:P:I, events(R:I, operationInvoked(O:P)),
    member(C, Cs)
    .
\end{verbatim}

\subsection{Obtaining a server result}

\begin{verbatim}
rinst(R:I, C, XS, rte_Result(O:P,K))  --- say(O:P:I,res(V)) --->        rinst(R:I, C, XS, ap(K,V))  .
rinst(A, O:P:I, [], return(V))        --- say(O:P:I,ret(V)) --->        rinst(A, nil, [], return(void)).
opres(O:P:I, [V|Vs])                  --- hear(O:P:I,res(V)) --->       opres(O:P:I, Vs)               .
opres(O:P:I, [])                      --- hear(O:P:I,res(no_data)) ---> opres(O:P:I, [])
    :-    async_result(O:P:I)   .
opres(O:P:I, Vs)                      --- hear(O:P:I,ret(V)) --->       opres(O:P:I, Vs++[V]) .
\end{verbatim}

\subsection{Spawning and terminating}

\begin{verbatim}
rinst(A, nil, [], return(_V))            --- say(A,term) --->     []    .
runnable(A, K, T, Act, N)                --- hear(A,term) --->    runnable(A, K, T, Act, N-1).
\end{verbatim}
Note the "time left" state has to be zero for these rules to fire.

\begin{verbatim}
runnable(A, K, 0, pending, N)            --- say(A,new) --->    [ runnable(A, K, T, idle, N+1)
                                                                , rinst(A, nil, [], ap(K,void)) ]
    :-
    (N == 0 ; canBeInvokedConcurrently(A)),
    minimumStartInterval(A, T)
    .
runnable(A, K, 0, serving([C|Cs],[V|Vs]), N) --- say(A,new) --->   [ runnable(A, K, T, serving(Cs,Vs), N+1)
                                                                   , rinst(A, C, [], ap(K,V)) ]
    :-
    (N == 0 ; canBeInvokedConcurrently(A)),
    minimumStartInterval(A, T)
    .
\end{verbatim}
\subsection{Passing time}

\begin{verbatim}
timer(A, 0)                 --- say(A,tick) --->  timer(A, T)                :-    events(A, timing(T))    .
runnable(A, K, T, _, N)     --- hear(A,tick) ---> runnable(A, K, T, pending, N) .
\end{verbatim}

The "time left" state V is always decreasing in delta(T) steps, and never negative.
\begin{verbatim}
timer(A, V)                 --- delta(T) --->     timer(A, V-T)               :-    V >= T.
runnable(A, K, V, Act, N)   --- delta(T) --->     runnable(A, K, V-T, Act, N) :-    V >= T.
runnable(A, K, 0, Act, N)   --- delta(_T) --->    runnable(A, K, 0, Act, N)   .
rinst(A, C, XS, Code)       --- delta(_T) --->    rinst(A, C, XS, Code)       .
excl(A, V)                  --- delta(_T) --->    excl(A, V)                  .
irv(A, V)                   --- delta(_T) --->    irv(A, V)                  .
qelem(A, N, Vs)             --- delta(_T) --->    qelem(A, N, Vs)            .
delem(A, U, V)              --- delta(_T) --->    delem(A, U, V)             .
opres(A, Vs)                --- delta(_T) --->    opres(A, Vs)               .
\end{verbatim}


\subsection{Ignoring broadcasts}

\begin{verbatim}
ignore(_AL, rinst(_B,_C,_Xs,_K))   .
ignore(_AL, timer(_B,_T))             .

ignore((A,_L), runnable(B, _K, _T, _Act, _N))   :- A \== B.
ignore((A,_L), excl(B,_V))                      :- A \== B.
ignore((A,_L), irv(B,_V))                       :- A \== B.
ignore((A,_L), qelem(B,_N,_Vs))                 :- A \== B, \+ A==>B.
ignore((A,_L), delem(B,_U,_V))                  :- A \== B, \+ A==>B.
ignore((A,_L), opres(B,_Vs))                    :- A \== B, \+ A==>B.
\end{verbatim}


\subsection{Helper predicate: flattening and evaluating reduction results}

\begin{verbatim}
flateval([],              Q, Q)  :- !  .
flateval([ M | P ],       Q, R)  :- !, flateval(P, Q, R1),  flateval(M, R1, R)  .
flateval(rinst(A,C,Xs,M), Q, [ rinst(A,C,Xs,N) | Q ])  :- !, eval(M, N)   .
flateval(M,               Q, [ M               | Q ]).
\end{verbatim}

Experiment with "treelike" process soup
\begin{verbatim}
treeeval([],              [])         :- !  .
treeeval([ M | P ],       [M2 | P2])  :- !, treeeval(M, M2), treeeval(P, P2).
treeeval(rinst(A,C,Xs,M), [ rinst(A,C,Xs,N) | _Q ])  :- !, eval(M, N)   .
treeeval(M,               [ M               | _Q ]).
\end{verbatim}

\subsection{Helper predicate: evaluating terms}

\begin{verbatim}
eval(V, V)              :-    var(V), !    .
eval(ap(T,V), ap(T,V))  :-    var(T), !    .
eval(ap(F,E), R)        :-    eval(F, fn(X,T)), !,    eval(E, V),    X = V,    eval(T, R)    .
eval(ap(T,_V), R)       :- !, eval(T, R)   .
eval(fn(X,T), fn(X,T))  :- ! .
eval(if(E,A,_B), R)     :-    E,    !, eval(A, R)    .
eval(if(E,_A,B), R)     :-    \+ E, !, eval(B, R)    .
eval((A,B), (A1,B1))    :- !, eval(A, A1),     eval(B, B1)    .
eval([A|B], [A1|B1])    :- !, eval(A, A1),     eval(B, B1)    .
eval((A:B), (A1:B1))    :- !, eval(A, A1),     eval(B, B1)    .
eval(E, R)              :-    E =.. [H|As], funWithArgsToEvaluate(H), !, eval(As, Bs), R =.. [H|Bs].
eval(V, V)              :-    atom(V), !  .
eval(E, R)              :-    R is E      .

funWithArgsToEvaluate(H):- name(H,N), (append("rte_",_,N) ; N = "return").
\end{verbatim}
