\documentclass[twocolumn]{article}
\usepackage{verbatim}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=1.4cm]{geometry}
\usepackage[fleqn]{amsmath}
\usepackage{mathpartir}
\usepackage{ amssymb }
% \usepackage{minted}
\title{A semantics of core AUTOSAR}
\author{Johan Nordlander \and Patrik Jansson}
%%%%%%%
\input{macros.tex}
\input{semantics.tex}

\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 2pt minus 1pt}

\begin{document}
\maketitle
\begin{abstract}


\end{abstract}

\section{Introduction}
\label{sec:Intro}

The AUTOSAR standard is an open software component architecture for the automotive industry. Its main purpose is to enable interoperability of software modules among different vendors and on heterogeneous platforms, via an extensive set of standardized interfaces and libraries, and a common software development methodology.

The standard has a rather wide scope and covers many features normally associated with complex operating systems, like I/O abstraction, concurrency, communication, distribution and real-time predictability. Unlike existing operating systems, however, AUTOSAR is not de facto defined in terms of a particular implementation. Instead, an explicit goal of AUTOSAR is to constitute an abstract specification that allows multiple and competing realizations, and even systems built as an assembly of fragments from many different (and competing) vendors. Such a goal naturally puts a heavy focus on the standard specification itself.

Unfortunately, the AUTOSAR specification is not very rigorous, despite a sheer size of more than 12,500 pages of text and UML diagrams in total. It is also not very abstract, in that it makes frequent references to assumed implementation techniques for the purpose of defining its semantics. In practice, the AUTOSAR standard becomes blurred with the specific behavior of one's chosen platform and development tools. And because the standard is open to interpretation, the interoperability of software components across tools and platforms is often seriously hampered. What is more, a single software component cannot easily be studied and understood in isolation, since its interactive behavior is only indirectly defined in terms of the concrete C-code and OS tasks that realize it and its interaction environment.

This paper takes an important step towards a remedy to these problems, by contributing a formal specification of a substantial core of the AUTOSAR standard. The formalization covers most of the Software Component Template and its accompanying Run-Time Environment (RTE) (Section~\ref{sec:Calc}), and is able to directly express every legal way a system of software components can evolve at run-time on an arbitrarily fast platform (Section~\ref{sec:Sem}). It can thus serve as a basis for both a concrete AUTOSAR implementation on a specific platform (whose supported behaviors must be a subset of those defined by the formal semantics), and a platform-independent AUTOSAR simulator (where behaviors from the legal set can be picked at random). Examples of semantic derivations and their applications are found in Section~\ref{sec:Examples}.

The semantics has been formalized with the intent to accurately capture the informal meaning of the AUTOSAR standard, although mistakes and misunderstandings are certainly both possible and plausible. A formal notation is nevertheless a good starting point for any discussion on the resolution of such issues. The semantics is furthermore written to be unambiguous, except where concurrent execution should allow for more than one observed behavior. At some points, the AUTOSAR documents have been found unclear; here a specific choice has been made but alternative interpretations will be discussed separately (Section~\ref{sec:DiscAmb}). At other points, the standard documents are clear but the resulting semantics is still dubious. These cases will also be emphasized and discussed, together with suggested ways forward (Section~\ref{sec:DiscImp}).


TODO: Limitations

TODO: Simple examples early (informally)

\section{AUTOSAR}
\label{sec:autosar}

An AUTOSAR model is primarily a structure of interconnected \textbf{software components} (SWCs). Links between SWCs are called \textbf{connectors}, which attach to \textbf{ports} exposed by the SWCs. A port is either \textbf{required} or \textbf{provided}, and then classified according to what \textbf{interface} it exposes: \textbf{sender-receiver}, \textbf{client-server}, \textbf{trigger} and \textbf{mode-switch} are common interface types. A sender-receiver interface is an aggregation of one or more \textbf{data-elements}, with each element characterized by the type of data it carries and optional further communication specification details. A client-server interface likewise consists of one or more \textbf{operations}, that each give the signature of a procedure call and the possible errors that may result.

Some components merely act as containers of other components structures, these are called \textbf{composition} SWCs. In contrast, \textbf{atomic} SWCs define their own behavior in terms of \textbf{runnables} and \textbf{inter-runnable variables}, primarily. A runnable denotes a sequential and (normally) terminating piece of code, although its actual behavioral definition is typically relegated to external C or Matlab files rather than being part of the AUTOSAR model proper. Instead, an AUTOSAR runnable  only provides constraints on what ports and inter-runnable variables the actual implementation can access; as well as \textbf{event} declarations that determine under what conditions it will get executed.

A runnable under execution is called a \textbf{runnable instance}, and these may execute concurrently even if they belong to the same SWC. Each runnable indicates whether or not it may be instantiated concurrently with itself. Runnable code can also use \textbf{exclusive areas} (a form of mutex semaphores) to further control concurrent behavior.

To interact with ports, inter-runnable variables and exclusive areas, runnables use what is abstractly known as the \textbf{virtual function bus} (VFB). Concretely, the VFB takes the shape of a C programming interface to the \textbf{run-time environment} (RTE), custom-generated for each runnable on the basis of its access constraints. Behind the RTE, a collection of OS kernels, communication stacks and other basic software modules implement the VFB services for the platform at hand. Complete AUTOSAR designs also typically contain \textbf{ECU} and \textbf{task assignments}, which are manually built tables that control how SWCs and runnables map onto the available hardware and OS resources, respectively.

AUTOSAR models are completely static, which means that all components, runnables, ports, connectors, etc, are created ahead of execution time. Runnable instances are an exception, but they are only identified by AUTOSAR for conceptual purposes and are never part of any model syntax. This static nature renders AUTOSAR models very suitable to graphical notations, which by far is the most widespread representation format for AUTOSAR models. A graphical model example is shown in Figure~\ref{fig:model}.

TODO: add fig:model

\section{Syntax and preliminaries}
\label{sec:Calc}

The formal approach we have chosen is that of a typical process calculus \cite{TODO}, where a system of concurrent processes evolves in a sequence of atomic steps, as determined by a global set of transition rules. Our process terms correspond to the individual state-carrying parts of an AUTOSAR system, like the runnables, runnable instances, inter-runnable variables and port elements. Each such term is also assigned a constant address parameter for identification purposes.

Components and ports do not carry any dynamic state besides the state of their constituent parts, so they need no explicit representation as process terms. However, in order to still be able to talk about model elements using their locally scoped names, we employ a hierarchical addressing scheme, such that address $\Tr{\V{R}}{\V{I}}$ means runnable \V{R} of component \V{I} and $\Tep{\V{E}}{\V{P}}{\V{I}}$ means element \V{E} of port \V{P} within component \V{I}. We use the following meta-variable conventions:

%
\[
\begin{array}{rcll}
  \V{I} & \in & \text{Component names} \\
  \V{R} & \in & \text{Runnable names} \\
  \V{P} & \in & \text{Port names} \\
  \V{E} & \in & \text{Sender-receiver element names} \\
  \V{O} & \in & \text{Client-server operation names} \\
  \V{S} & \in & \text{Inter-runnable variable names} \\
  \V{X} & \in & \text{Exclusive area names} \\
\\
  \V{A},\V{B} & \in & \text{Addresses} \\
  \V{A},\V{B} & ::= & \Tr{\V{R}}{\V{I}}   \sep   i.p  \sep  \Tep{\V{E}}{\V{P}}{\V{I}}   \sep \Top{\V{O}}{\V{P}}{\V{I}}   \sep   \Ts{\V{S}}{\V{I}}   \sep   \Tx{\V{X}}{\V{I}}   \\
\end{array}
\]
%
Since AUTOSAR components can be arbitrarily nested, the component names \V{I} can also be considered to have a similarly nested internal structure (component \V{I_1} within component \V{I_2} within component \V{I_3}, etc). We can fully ignore this detail here, though, as the hierarchical layout of components in an AUTOSAR system has no run-time implications \cite{TODO2}.

The process terms of our calculus are as follows:
\begin{itemize}
\item $\Trunnable{\Tr{\V{R}}{\V{I}}}{\V{T}}{\Act}{\V{N}}$  \newline
Dynamic state for runnable \V{R} of component \V{I}, indicating \V{N} current instances, \V{T} seconds left until next possible instantiation, and activation state $\Act$.
\item $\Trinst{\Tr{\V{R}}{\V{I}}}{\V{C}}{\Xs}{\Code}$ \newline
An instance of runnable \V{R} of component \V{I}, currently executing $\Code$ and owning the exclusive areas $\Xs$, possibly running on behalf of client \V{C}.
\item $\Texcl{\Tx{\V{X}}{\V{I}}}{\V{U}}$ \newline
Exclusive area \V{X} of component \V{I}, with boolean occupation state \V{U}.
\item $\Tirv{\Ts{\V{S}}{\V{I}}}{\V{V}}$ \newline
Inter-runnable variable \V{S} of component \V{I}, currently holding value \V{V}.
\item $\Tdelem{\Tep{\V{E}}{\V{P}}{\V{I}}}{\V{U}}{\V{V}}$ \newline
Non-queued sender-receiver data element \V{E} in port \V{P} of component \V{I}, currently holding value \V{V} with boolean update status flag \V{U}.
\item $\Tqelem{\Tep{\V{E}}{\V{P}}{\V{I}}}{\V{N}}{\Vs}$ \newline
Queued sender-receiver data element \V{E} in port \V{P} of component \V{I} with maximum capacity \V{N}, currently holding value sequence \Vs.
\item $\Topres{\Top{\V{O}}{\V{P}}{\V{I}}}{\Vs}$ \newline
Client-server operation \V{O} in port \V{P} of component \V{I}, currently holding result value sequence \Vs.
\item $\Ttimer{\Tr{\V{R}}{\V{I}}}{\V{T_p}}{\V{T}}$ \newline
Periodic timer for runnable \V{R} of component \V{I}, with a period of \V{T_p} and \V{T} seconds left of its current cycle.
\end{itemize}

In the untyped setting of this report, a value \V{V} can be any data item computed and communicated by an AUTOSAR system, including the unit value $\Tvoid$ and the error codes that might be returned from RTE calls. Meta-variables \V{N}, \V{U} and \V{T} range over natural numbers, boolean values and (floating point) time values, respectively. The client \V{C} of a runnable instance is the address of the invoking port operation (if the runnable was invoked by a client-server call), or $\Tvoid$ otherwise. An activation state $\Act$ either toggles between $\Tidle$ and $\Tpending$, or it has the special shape $\Tserving{\Cs}{\Vs}$ (in the case of a runnable triggered by client-server calls). Formally,
\[
\begin{array}{rcll}
  \V{V}    & \in & \text{Values} \\
  \V{N}    & \in & \text{Natural numbers} \\
  \V{U}    & \in & \text{Boolean values} \\
  \V{T}    & \in & \text{Time values} \\
  \V{C}    & \in & \text{Clients} \\
  \Act     & \in & \text{Activation states} \\ \\
  \V{C}    & ::= & \Top{\V{O}}{\V{P}}{\V{I}} \sep \Tvoid \\
  \Act     & ::= & \Tidle \sep \Tpending \sep \Tserving{\Cs}{\Vs} \\
\end{array}
\]
We write $\Vs$ for a sequence of values \V{V}, $\Cs$ for a sequence of clients \V{C}, etc. Sequences may be empty, which is written $\epsilon$. By $\Tlength{\Vs}$ we mean the length of sequence $\Vs$. Left (right) concatenation of an element with a sequence is written $\Tcons{\V{V}}{\V{Vs}}$ ($\Tsnoc{\V{Vs}}{\V{V}}$).

The $\Code$ part of a runnable instance should technically be a representation of the C or Matlab implementation that must accompany an AUTOSAR runnable definition once it is complete. However, since our task in this report is not to investigate the semantics of these languages in any detail, a more abstract notion of executable code will be required.

To this end, we have chosen to ignore all internal computations and just capture the observable effects of runnable execution as a pure sequence of RTE (VFB) calls. And because the result from an RTE call may in general affect subsequent runnable behavior, we use a continuation-passing style where every $\Code$ term except the final function return actually contains the sequence that follows it as a continuation function $\Cont$.
%
\[
\begin{array}{lll}
  \Code & \in & \text{Code}								\\
  \Cont & \in & \text{Values} \rightarrow \text{Code}   \\ \\
  \Code & ::= & \Enter{\V{X}}{\Cont}                \\
        & |   & \Exit{\V{X}}{\Cont}                 \\
        & |   & \IrvWrite{\V{S}}{\V{V}}{\Cont}          \\
        & |   & \IrvRead{\V{S}}{\Cont}              \\
        & |   & \Send{\Te{\V{E}}{\V{P}}}{\V{V}}{\Cont}      \\
        & |   & \Receive{\Te{\V{E}}{\V{P}}}{\Cont}      \\
        & |   & \Write{\Te{\V{E}}{\V{P}}}{\V{V}}{\Cont}     \\
        & |   & \Read{\Te{\V{E}}{\V{P}}}{\Cont}         \\
        & |   & \Invalidate{\Te{\V{E}}{\V{P}}}{\Cont}   \\
        & |   & \IsUpdated{\Te{\V{E}}{\V{P}}}{\Cont}    \\
        & |   & \Call{\To{\V{O}}{\V{P}}}{\V{V}}{\Cont}      \\
        & |   & \Result{\To{\V{O}}{\V{P}}}{\Cont}       \\
        & |   & \Return{\V{V}}                      \\
\end{array}
\]

In contrast to $\Code$ sequences, process terms are completely unordered. This is expressed in the standard process calculus style, using an associative operator $\Tpar{}{}$ that allows arbitrary sets of primitive processes to be composed in parallel. This operator also has a left and right unit in the form of process $\Tzero$, which stands for the empty, or terminated, process. The complete grammar for our process terms thus looks as follows:

\[
\begin{array}{rcll}
  \V{P},\V{Q}   
  		& ::= & \Trunnable{\V{A}}{\V{T}}{\Act}{\V{N}}    \\
        & |   & \Trinst{\V{A}}{\V{C}}{\Xs}{\Code}       \\
        & |   & \Texcl{\V{A}}{\V{U}}                    \\
        & |   & \Tirv{\V{A}}{\V{V}}                     \\
        & |   & \Tdelem{\V{A}}{\V{U}}{\V{V}}            \\
        & |   & \Tqelem{\V{A}}{\V{N}}{\Vs}              \\
        & |   & \Topres{\V{A}}{\Vs}                     \\
        & |   & \Ttimer{\V{A}}{\V{T_p}}{\V{T}}          \\
        & |   & \Tpar{\V{P}}{\V{Q}}                     \\
        & |	  & \Tzero									\\
\end{array}
\]

TODO: links from syntax and concepts introduced here to the AUTOSAR spec

TODO: details on limitations: what's not covered by the calculus


\section{Semantics}
\label{sec:Sem}

Our semantic approach defines the meaning of an AUTOSAR system as the possible chains of state changes that can be applied to the system's initial state; or equivalently, as the set of \emph{traces} that can be generated from the initial process term \V{P_0}. A trace is a possibly infinite sequence of transitions
\[
\begin{array}{c}
  \V{P_0} \red{\V{L_1}} \V{P_1} \red{\V{L_2}} \V{P_2} \red{\V{L_3}} \cdots
\end{array}
\]
where each step
\[
\begin{array}{c}
  \V{P_{i-1}} \red{\V{L_i}} \V{P_i}
\end{array}
\]
states that the system state captured as process term \V{P_{i-1}} can evolve into state \V{P_i} by means of a single transition labelled \V{L_i}.

The label \V{L} of a transition can essentially be of two kinds, indicating that the affected process either "says" or "hears" something during the transition. Such a label always consists of an address \V{A} paired with some additional detail \V{D}. There is also a special form of "hearing" that denotes letting time pass and which does not carry any address. The different labels are captured in the following label grammar. 
\[
\begin{array}{rcll}
  \V{L}     & ::= & \V{A}!\V{D} 	& \hspace{4em}\text{Say  \V{A} and \V{D}} \\
            & |   & \V{A}?\V{D} 	& \hspace{4em}\text{Hear \V{A} and \V{D}} \\
            & |   & \Tdelta{\V{T}}	& \hspace{4em}\text{Let \V{T} seconds pass} \\
\end{array}
\]
The possible forms of the extra label information \V{D} will be introduced as the different transition rules are defined.

Two processes \V{P} and \V{Q} can make transitions in parallel if they agree on what is being said or heard. Just as the saying/hearing intuition suggests, at most one of the processes can have the saying role in such an agreement. The following set of inference rules capture this intuition formally.
{
\renewcommand{\Prule}[2]{#1 & \Pif & #2\\}

\[ \begin{array}{@{}r@{}c@{}l@{\quad\;}c@{\;\,}r@{}c@{}l@{}r@{}c@{}l}  \CombRed  \end{array} \]
}


The effect of these agreement rules closely resembles the idea of a \emph{broadcast}: what one process says may be heard by every other process in a large parallel composition. This behavior serves us well, because in general, what one AUTOSAR runnable does may have impact on many (if not all) parts of the executing system. It is however important not to confuse this broadcasting notion with any particular form of AUTOSAR communication. The way transition labels distribute over the parallel composition operator is merely a technical aspect of our process calculus, and will be used to express several different AUTOSAR communication semantics, among other things.

The initial process \V{P_0} is determined fully by the AUTOSAR model under study, as the parallel composition of the following terms:
\begin{enumerate}

\item For each runnable \V{R} of each component \V{I}, a term
\[
\begin{array}{c}
  \Trunnable{\Tr{\V{R}}{\V{I}}}{0}{\Act}{0}
\end{array}
\]
where $\Act$ is $\Tserving{\epsilon}{\epsilon}$ if \V{R} is triggered by an \emph{OperationInvokedEvent}; else $\Act$ is $\Tpending$ if \V{R} is triggered by an \emph{InitEvent}; otherwise $\Act$ is $\Tidle$.
% SWS_Rte_03524 (SWS_Rte_03526?) forbids mixing OperationInvokedEvents with other events for the same runnable

\item For each exclusive area \V{X} of each atomic component \V{I}, a term
\[
\begin{array}{c}
  \Texcl{\Tx{\V{X}}{\V{I}}}{\Tfalse}
\end{array}
\]

\item For each inter-runnable variable \V{S} of each atomic component \V{I}, a term
\[
\begin{array}{c}
  \Tirv{\Ts{\V{S}}{\V{I}}}{\V{V}}
\end{array}
\]
where \V{V} is the \emph{initValue} attributed to \V{S} if it exists, otherwise \V{V} is $\Tvoid$.

\item For each data element \V{E} of each required port \V{P} of each atomic component \V{I}, a term
\[
\begin{array}{c}
  \Tqelem{\Tep{\V{E}}{\V{P}}{\V{I}}}{\V{N}}{\epsilon}
\end{array}
\]
if the \emph{swImplPolicy} attribute of element \V{E} is \emph{queued} (with capacity \V{N}); otherwise, a term
\[
\begin{array}{c}
  \Tdelem{\Tep{\V{E}}{\V{P}}{\V{I}}}{\Tfalse}{\Tnodata}
\end{array}
\]

\item For each operation \V{O} of each required port \V{P} of each atomic component \V{I}, a term
\[
\begin{array}{c}
  \Topres{\Tep{\V{O}}{\V{P}}{\V{I}}}{\epsilon}
\end{array}
\]

\item For each \emph{TimingEvent} triggering each runnable \V{R} of each atomic component \V{I}, a term
\[
\begin{array}{c}
  \Ttimer{\Tr{\V{R}}{\V{I}}}{\V{T_p}}{0}
\end{array}
\]
where \V{T_p} is the period of the event.
%TODO: This means that all timed runnables want to act _immediately_ (at the same time - with no init delay).

\end{enumerate}

Some further static model information will also be referenced by the transition rules. We refer to the connectors of a model using a binary relation $\Rightarrow$ on port addresses, where the arrow points in the \emph{provided-to-required} direction. We also assume that $\Rightarrow$ is transitively closed (i.e., it expresses end-to-end connectivity across \emph{Delegation-} as well as \emph{AssemblySwConnector}s), and that every connection $a \Rightarrow b$ is lifted to the \emph{DataElement}s and \emph{ClientServerOperation}s of the connected ports such that
\[
\begin{array}{lll}
  \Tconnect{\Tp{e}{a}}{\Tp{e}{b}} & \text{for all elements $e$ of port $b$} \\
  \Tconnect{\Tp{o}{a}}{\Tp{o}{b}} & \text{for all operations $o$ of port $b$} \\
\end{array}
\]

We expect the implementation of a runnable to be available as a continuation function $\Cont$, even though the real AUTOSAR model will be refering to concrete functions in external C/Matlab files. We will further abstract away from actual numbers of input and output parameters to these functions by assuming that records (structs) are used as the single continuation argument and result whenever the arity so requires. Absent arguments or results will be replaced by the unit value $\Tvoid$.

We write $\Timplementation{i.r}{k}$ to state the assumption that the static AUTOSAR model under study assigns implementation function $k$ to runnable $i.r$. Similar notations will be used to express other references to the underlying static model; for example $\emph{DataReceivedEvent}(i.r, p.e)$ to state that the model allows runnable $i.r$ to be triggered by data reception events on port $p.e$ (in component $i$). Although the chosen notation is sometimes significantly shorter than the UML/XML-based syntax used in the AUTOSAR specification, the intended meaning should nevertheless be clear.

\subsection{Exclusive areas}


\subsection{Inter-runnable variables}



TODO: some links from rules and choices made here to the AUTOSAR spec

\section{Examples}
\label{sec:Examples}

\begin{itemize}
\item More details on the simple examples + a bigger example.
\item Some examples chosen to illustrate the value of a formal calculus
\end{itemize}

\section{Discussion / results}
\label{sec:Disc}

\subsection{Ambiguities and alternative interpretations}
\label{sec:DiscAmb}

\subsection{Clarification proposals and improvements}
\label{sec:DiscImp}

irv without initValue vs.\ delem without initValue -- "undefined" vs.\ NO\_DATA at initial read.

Mixing OperationInvokedEvents with others for same runnable...

Multiple timingEvent for same runnable, possibly with same period?

Exclusive area nesting

Return value of qelem write with fanout > 1 and *some* LIMIT failures

Timer initial offsets

Rule and examples of provided delegation port compatibility don't match

Multiple inconsistent CompSpecs


\section{Conclusions and Future Work}
\label{sec:Conc}

Return to the limitation - what is the next step (which can be lifted more easily)

\onecolumn
\appendix
\section{Semantic rules}
\label{sec:Prolog}

\subsection{Exclusive areas}
\begin{eqnarray}      \ExclusiveAreas          \notag \end{eqnarray}

\subsection{Inter-runnable variables}
\begin{eqnarray}      \InterrunnableVariables  \notag \end{eqnarray}

\subsection{Sending/receiving}
\begin{eqnarray}      \SendingReceiving        \notag \end{eqnarray}

%TODO: RuleLong?
\subsection{Reading/writing (unbuffered versions of rcv and snd)}
\begin{eqnarray}      \ReadingWriting          \notag \end{eqnarray}

\subsection{Calling a server}

\renewcommand\Pcomma{\nonumber \\&&\text{and}\;\;}

\begin{eqnarray}      \CallServer              \notag \end{eqnarray}

\subsection{Passing back a server result}
\begin{eqnarray}      \ServerResult            \notag \end{eqnarray}

\subsection{Spawning and terminating}
\begin{eqnarray}      \SpawnTerminate          \notag \end{eqnarray}

\subsection{Passing time}
\begin{eqnarray}      \PassingTime             \notag \end{eqnarray}

%\renewcommand{\Prule}[2]{#1 & \Pif \;\; #2\\}
\subsection{Ignoring broadcasts}
\begin{eqnarray}      \IgnoreBroadcast         \notag \end{eqnarray}

\end{document}
