% -*- mode: Prolog -*-
% Copyright (c) 2014-2016, Johan Nordlander, Jonas Duregård, Michał Pałka,
%                          Patrik Jansson and Josef Svenningsson
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%    * Redistributions of source code must retain the above copyright notice,
%      this list of conditions and the following disclaimer.
%    * Redistributions in binary form must reproduce the above copyright
%      notice, this list of conditions and the following disclaimer in the
%      documentation and/or other materials provided with the distribution.
%    * Neither the name of the Chalmers University of Technology nor the names of its
%      contributors may be used to endorse or promote products derived from this
%      software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
% FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
% DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
% SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
% CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
% OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
% OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

%%%%% Combining reductions
begingroup(CombRed).

step( par(P_1,Q_1), say(A,D),  par(P_2,Q_2) ) :- step( P_1, say(A,D),  P_2 ), step( Q_1, hear(A,D), Q_2 ).
step( par(P_1,Q_1), say(A,D),  par(P_2,Q_2) ) :- step( P_1, hear(A,D), P_2 ), step( Q_1, say(A,D),  Q_2 ).
step( par(P_1,Q_1), hear(A,D), par(P_2,Q_2) ) :- step( P_1, hear(A,D), P_2 ), step( Q_1, hear(A,D), Q_2 ).
step( par(P_1,Q_1), delta(T),  par(P_2,Q_2) ) :- step( P_1, delta(T),  P_2 ), step( Q_1, delta(T),  Q_2 ).

endgroup(CombRed).

%%%%% Exclusive areas
begingroup(ExclusiveAreas).

% Strict stack-based locking enforced: reduction gets stuck otherwise
%   (TODO: comment about flagging error on attempted "bad" rte_Exit?)

step( rinst(r(R,I), C, Xs, rte_Enter(X,K)),              say(x(X,I),ent),             rinst(r(R,I), C, cons(X,Xs), ap(K,void)) ).
step( rinst(r(R,I), C, cons(X,Xs), rte_Exit(X,K)),       say(x(X,I),ex),              rinst(r(R,I), C, Xs, ap(K,void))         ).

step( excl(x(X,I), false),                               hear(x(X,I),ent),            excl(x(X,I), true)                       ).
step( excl(x(X,I), true),                                hear(x(X,I),ex),             excl(x(X,I), false)                      ).

endgroup(ExclusiveAreas).

%%%%% Inter-runnable variables

begingroup(InterrunnableVariables).

step( rinst(r(R,I), C, Xs, rte_IrvRead(S,K)),            say(s(S,I),irvr(V)),           rinst(r(R,I), C, Xs, ap(K,V))          ).
step( rinst(r(R,I), C, Xs, rte_IrvWrite(S,V,K)),         say(s(S,I),irvw(V)),           rinst(r(R,I), C, Xs, ap(K,void))       ).

step( irv(s(S,I), V),                                    hear(s(S,I),irvr(V)),          irv(s(S,I), V)                         ).
step( irv(s(S,I), _),                                    hear(s(S,I),irvw(V)),          irv(s(S,I), V)                         ).

endgroup(InterrunnableVariables).

%%%%% Sending/receiving

begingroup(SendingReceiving).

step( rinst(r(R,I), C, Xs, rte_Receive(e(E,P),K)),       say(ep(E,P,I),rcv(V)),          rinst(r(R,I), C, Xs, ap(K,V))         ).
step( rinst(r(R,I), C, Xs, rte_Send(e(E,P),V,K)),        say(ep(E,P,I),snd(V,eps)),      rinst(r(R,I), C, Xs, ap(K,ok))        ).
step( rinst(r(R,I), C, Xs, rte_Send(e(E,P),V,K)),        say(ep(E,P,I),snd(V,As)),       rinst(r(R,I), C, Xs, ap(K,limit))     ) :-
    notequal(As,eps).

step( qelem(ep(E,P,I), N, cons(V,Vs)),                   hear(ep(E,P,I),rcv(V)),         qelem(ep(E,P,I), N, Vs)               ).
step( qelem(ep(E,P,I), N, eps),                          hear(ep(E,P,I),rcv(nodata)),    qelem(ep(E,P,I), N, eps)              ).
step( qelem(ep(E,P,I), N, Vs),                           hear(A,snd(V,As)),              qelem(ep(E,P,I), N, seq(Vs,V))        ) :-
    connect(A,ep(E,P,I)), less(length(Vs),N), notmember(ep(E,P,I),As).
step( qelem(ep(E,P,I), N, Vs),                           hear(A,snd(_,As)),              qelem(ep(E,P,I), N, Vs)               ) :-
    connect(A,ep(E,P,I)), equal(length(Vs),N), member(ep(E,P,I),As).

step( runnable(r(R,I), T, _, N),                         hear(A,snd(_,As)),              runnable(r(R,I), T, pending, N)       ) :-
    connect(A,ep(E,P,I)),
    dataReceivedEvent(r(R,I),e(E,P)),
    notmember(ep(E,P,I),As).
step( runnable(r(R,I), T, Act, N),                       hear(A,snd(_,As)),              runnable(r(R,I), T, Act, N)           ) :-
    connect(A,ep(E,P,I)),
    dataReceivedEvent(r(R,I),e(E,P)),
    member(ep(E,P,I),As).

endgroup(SendingReceiving).

%%%%% Reading/writing (unbuffered versions of rcv and snd)

begingroup(ReadingWriting).

step( rinst(r(R,I), C, Xs, rte_Read(e(E,P),K)),          say(ep(E,P,I),rd(V)),           rinst(r(R,I), C, Xs, ap(K,V))         ).
step( rinst(r(R,I), C, Xs, rte_Write(e(E,P),V,K)),       say(ep(E,P,I),wr(V)),           rinst(r(R,I), C, Xs, ap(K,void))      ).

step( delem(ep(E,P,I), _, V),                            hear(ep(E,P,I),rd(V)),          delem(ep(E,P,I), false, V)            ).
step( delem(ep(E,P,I), _, _),                            hear(A,wr(V)),                  delem(ep(E,P,I), true, V)             ) :-
    connect(A,ep(E,P,I)).

step( runnable(r(R,I), T, _, N),                         hear(A,wr(_)),                  runnable(r(R,I), T, pending, N)       ) :-
    connect(A,ep(E,P,I)),
    dataReceivedEvent(r(R,I),e(E,P)).

step( rinst(r(R,I), C, Xs, rte_IsUpdated(e(E,P),K)),     say(ep(E,P,I),up(U)),           rinst(r(R,I), C, Xs, ap(K,U))         ).
step( rinst(r(R,I), C, Xs, rte_Invalidate(e(E,P),K)),    say(ep(E,P,I),inv),             rinst(r(R,I), C, Xs, ap(K,void))      ).

step( delem(ep(E,P,I), U, V),                            hear(ep(E,P,I),up(U)),          delem(ep(E,P,I), U, V)                ).
step( delem(ep(E,P,I), _, _),                            hear(A,inv),                    delem(ep(E,P,I), true, invalid)       ) :-
    connect(A,ep(E,P,I)).

endgroup(ReadingWriting).

%%%%% Calling a server

begingroup(CallServer).

step( rinst(r(R,I), C, Xs, rte_Call(o(O,P),V,K)),   say(op(O,P,I),call(V,ok)),      rinst(r(R,I), C, Xs, rte_Result(o(O,P),K))                      ) :-
    synchronousServerCallPoint(r(R,I),o(O,P)).
step( rinst(r(R,I), C, Xs, rte_Call(o(O,P),V,K)),   say(op(O,P,I),call(V,ok)),      rinst(r(R,I), C, Xs, ap(K,Res))                                 ) :-
    asynchronousServerCallPoint(r(R,I),o(O,P)).
step( rinst(r(R,I), C, Xs, rte_Call(o(O,P),V,K)),   say(op(O,P,I),call(V,limit)),   rinst(r(R,I), C, Xs, ap(K,Res))                                 ).

step( runnable(r(R,I), T, serving(Cs,Vs), N),       hear(A,call(V,ok)),             runnable(r(R,I), T, serving(seq(Cs,A),seq(Vs,V)), N)            ) :-
    connect(op(O,P,I),A),
    operationInvokedEvent(r(R,I),o(O,P)),
    notmember(A,Cs).
step( runnable(r(R,I), T, serving(Cs,Vs), N),       hear(A,call(_,limit)),          runnable(r(R,I), T, serving(Cs,Vs), N)                       ) :-
    connect(op(O,P,I),A),
    operationInvokedEvent(r(R,I),o(O,P)),
    member(A,Cs).

endgroup(CallServer).

%%%%% Returning a server result

begingroup(ServerResult).

step( rinst(r(R,I), C, Xs, rte_Result(o(O,P),K)),   say(op(O,P,I),res(V)),          rinst(r(R,I), C, Xs, ap(K,V))                                   ) :-
    notequal(V,nodata).
step( rinst(r(R,I), C, Xs, rte_Result(o(O,P),K)),   say(op(O,P,I),res(nodata)),     rinst(r(R,I), C, Xs, ap(K,V))                                   ) :-
    asynchronousServerCallResultPoint(r(R,I),o(O,P)).
step( rinst(A, op(O,P,I), eps, return(V)),          say(op(O,P,I),ret(V)),          rinst(A, void, eps, return(void))                                ).

step( opres(op(O,P,I), cons(V,Vs)),                 hear(op(O,P,I),res(V)),         opres(op(O,P,I), Vs)                                            ).
step( opres(op(O,P,I), Vs),                         hear(op(O,P,I),ret(V)),         opres(op(O,P,I), seq(Vs,V))                                     ).
step( opres(op(O,P,I), eps),                        hear(op(O,P,I),res(nodata)),    opres(op(O,P,I), eps)                                           ).

endgroup(ServerResult).

%%%%% Spawning and terminating

begingroup(SpawnTerminate).

step( rinst(A, void, eps, return(_)),                         say(A,term),    zero                                                                  ).
step( runnable(A, T, Act, N),                                 hear(A,term),   runnable(A, T, Act, minus(N,1))                                       ).
step( runnable(A, 0, pending, 0),                             say(A,new),     par( runnable(A, T, idle, 1),
                                                                                   rinst(A, void, eps, ap(K,void)) )                                 ) :-
    minimumStartInterval(A,T),
    implementation(A,K).
step( runnable(A, 0, pending, N),                             say(A,new),     par( runnable(A, T, idle, plus(N,1)),
                                                                                   rinst(A, void, eps, ap(K,void)) )                                 ) :-
    canBeInvokedConcurrently(A),
    minimumStartInterval(A,T),
    implementation(A,K).

step( runnable(A, 0, serving(cons(C,Cs),cons(V,Vs)), 0),      say(A,new),     par( runnable(A, T, serving(Cs,Vs), 1),
                                                                                   rinst(A, C, eps, ap(K,V)) )                                      ) :-
    minimumStartInterval(A,T),
    implementation(A,K).
step( runnable(A, 0, serving(cons(C,Cs),cons(V,Vs)), N),      say(A,new),     par( runnable(A, T, serving(Cs,Vs), plus(N,1)),
                                                                                   rinst(A, C, eps, ap(K,V)) )                                      ) :-
    canBeInvokedConcurrently(A),
    minimumStartInterval(A,T),
    implementation(A,K).

endgroup(SpawnTerminate).

%%%%% Passing time

begingroup(PassingTime).

step( timer(A, T_p, 0),            say(A,tick),    timer(A, T_p, T_p)                 ).
step( runnable(A, T, _, N),        hear(A,tick),   runnable(A, T, pending, N)         ).

% The "time left" state V is always decreasing in delta(T) steps, and never negative.
step( timer(A, T_p, V),            delta(T),       timer(A, T_p, minus(V,T))          ) :-   lesseq(T,V).
step( runnable(A, V, Act, N),      delta(T),       runnable(A, minus(V,T), Act, N)    ) :-   lesseq(T,V).
step( runnable(A, 0, Act, N),      delta(_),       runnable(A, 0, Act, N)             ).
step( rinst(A, C, Xs, Code),       delta(_),       rinst(A, C, Xs, Code)              ).
step( excl(A, V),                  delta(_),       excl(A, V)                         ).
step( irv(A, V),                   delta(_),       irv(A, V)                          ).
step( qelem(A, N, Vs),             delta(_),       qelem(A, N, Vs)                    ).
step( delem(A, U, V),              delta(_),       delem(A, U, V)                     ).
step( opres(A, Vs),                delta(_),       opres(A, Vs)                       ).

endgroup(PassingTime).

%%%%% Ignoring broadcasts

begingroup(IgnoreBroadcast).

step( rinst(A, C, Xs, K),          hear(_,_),      rinst(A, C, Xs, K)                ).
step( timer(B, T_p, T),            hear(_,_),      timer(B, T_p, T)                  ).
step( runnable(B, T, Act, N),      hear(A,_),      runnable(B, T, Act, N)            ) :-   notequal(A,B).
step( excl(B, V),                  hear(A,_),      excl(B, V)                        ) :-   notequal(A,B).
step( irv(B, V),                   hear(A,_),      irv(B, V)                         ) :-   notequal(A,B).
step( qelem(B, N, Vs),             hear(A,_),      qelem(B, N, Vs)                   ) :-   notconnect(A,B).
step( delem(B, U, V),              hear(A,_),      delem(B, U, V)                    ) :-   notconnect(A,B).
step( opres(B, Vs),                hear(A,_),      opres(B, Vs)                      ) :-   notequal(A,B).

endgroup(IgnoreBroadcast).
